#
# $Id: opensips_residential.m4 9742 2013-02-05 10:24:48Z vladut-paiu $
#
# OpenSIPS residential configuration script
#     by OpenSIPS Solutions <team@opensips-solutions.com>
#
# This script was generated via "make menuconfig", from
#   the "Residential" scenario.
# You can enable / disable more features / functionalities by
#   re-generating the scenario with different options.#
#
# Please refer to the Core CookBook at:
#      http://www.opensips.org/Resources/DocsCookbooks
# for a explanation of possible statements, functions and parameters.
#


####### Global Parameters #########


debug=3
log_stderror=yes
#log_facility=LOG_LOCAL0

fork=yes
children=4

/* uncomment the following lines to enable debugging */
#debug=6
#fork=no
#log_stderror=yes

/* uncomment the next line to enable the auto temporary blacklisting of 
   not available destinations (default disabled) */
#disable_dns_blacklist=no

/* uncomment the next line to enable IPv6 lookup after IPv4 dns 
   lookup failures (default disabled) */
#dns_try_ipv6=yes

/* comment the next line to enable the auto discovery of local aliases
   based on revers DNS on IPs */
auto_aliases=no

alias="SIP_DOMAIN"

server_header="Server: SIP_HOST.SIP_DOMAIN"
server_signature=no

listen=udp:SIP_IPADDR:SIP_UDP   # CUSTOMIZE ME

disable_tcp=no

listen=tcp:SIP_IPADDR:SIP_TCP   # CUSTOMIZE ME 

tcp_children=60
tcp_max_connections=150000
tcp_keepalive=1
tcp_keepidle=60
#tcp_keepidle=30
tcp_keepinterval=60
#tcp_keepinterval=30
tcp_keepcount=3
#tcp_keepcount=10
#tcp_send_timeout=10
tcp_send_timeout=30
#tcp_connect_timeout=14
tcp_connect_timeout=30
#tcp_connection_lifetime=660
tcp_connection_lifetime=3600

open_files_limit=262144

disable_tls=0
listen = tls:SIP_IPADDR:SIP_TLS
tls_method=tlsv1
tls_certificate="/usr/local/etc/opensips/cert.pem"
tls_private_key="/usr/local/etc/opensips/privkey.pem"
tls_ca_list="/usr/local/etc/opensips/calist.pem"
tls_verify_client=0

####### Modules Section ########

#set module path
mpath="/usr/local/lib64/opensips/modules/"


#### SIGNALING module
loadmodule "signaling.so"


#### StateLess module
loadmodule "sl.so"


#### Transaction Module
loadmodule "tm.so"
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 60)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 0)	# Disable to improve performance
modparam("tm", "pass_provisional_replies", 1)

#### Record Route Module
loadmodule "rr.so"
/* do not append from tag to the RR (no need for this script) */
modparam("rr", "append_fromtag", 0)


#### MAX ForWarD module
loadmodule "maxfwd.so"


#### SIP MSG OPerationS module
loadmodule "sipmsgops.so"


#### DOMAIN module
loadmodule "domain.so"
modparam("domain", "db_mode", 1)
modparam("domain", "db_url", "DB_PROTO://DB_USER:DB_PASS@DB_HOST/opensips")


#### FIFO Management Interface
loadmodule "mi_fifo.so"
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")
modparam("mi_fifo", "fifo_mode", 0666)


#### URI module
loadmodule "uri.so"


#### MYSQL module
loadmodule "db_mysql.so"


#### CACHEDB_LOCAL module
loadmodule "cachedb_local.so"
modparam("cachedb_local", "cache_clean_period", 600)
modparam("cachedb_local", "cache_table_size", 20)


#### CACHEDB_MEMCACHED module
#loadmodule "cachedb_memcached.so"
#modparam("cachedb_memcached","cachedb_url","memcached://no.need.for.now:11211/")


#### USeR LOCation
loadmodule "usrloc.so"
modparam("usrloc", "matching_mode", 1)
modparam("usrloc", "nat_bflag", "NAT")
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "hash_size", 10)
#modparam("usrloc", "desc_time_order", 1)

#### REGISTRAR module
loadmodule "registrar.so"
modparam("registrar", "tcp_persistent_flag", "TCP_PERSISTENT")
modparam("registrar", "max_expires", 660)

loadmodule "auth.so"

#loadmodule "aaa_radius.so"
#modparam("aaa_radius", "syslog_name", "aaa-radius")

#loadmodule "auth_aaa.so"
#modparam("auth_aaa", "aaa_url", "radius:/etc/radiusclient-ng/radiusclient.conf")
#modparam("auth_aaa", "service_type", 15)

loadmodule "auth_db.so"
modparam("auth_db", "db_url", "DB_PROTO://DB_USER:DB_PASS@DB_HOST/radius")
modparam("auth_db", "user_column", "username")
modparam("auth_db", "domain_column", "op")
modparam("auth_db", "password_column", "value")
modparam("auth_db", "password_column_2", "value")
modparam("auth_db", "use_domain", 0)
modparam("auth_db", "calculate_ha1", 0)
modparam("auth_db", "skip_version_check", 1)
modparam("auth_db", "join", 1)


#### DIALOG module
loadmodule "dialog.so"
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "default_timeout", 21600)  # 6 hours timeout
modparam("dialog", "db_mode", 0)
modparam("dialog", "hash_size", 4096)


#### Management Interface module
loadmodule "mi_datagram.so"
modparam("mi_datagram", "socket_name", "/var/run/opensips/socket")


#### Media Proxy module
loadmodule "mediaproxy.so"
modparam("mediaproxy", "disable", 0)
modparam("mediaproxy", "mediaproxy_socket", "/run/mediaproxy/dispatcher.sock")
modparam("mediaproxy", "mediaproxy_timeout", 500)
modparam("mediaproxy", "signaling_ip_avp", "$avp(nat_ip)")
modparam("mediaproxy", "media_relay_avp", "$avp(media_relay)")
modparam("mediaproxy", "ice_candidate", "low-priority")
modparam("mediaproxy", "ice_candidate_avp", "$avp(ice_candidate)")


#### NAT Traversal module
loadmodule "nat_traversal.so"
modparam("nat_traversal", "keepalive_interval", 60)
modparam("nat_traversal", "keepalive_method", "NOTIFY")
modparam("nat_traversal", "keepalive_from", "sip:pinger@voxypad.com")
modparam("nat_traversal", "keepalive_state_file", "/var/run/opensips/keepalive_state")


#### PERL module
loadmodule "perl.so"
modparam("perl", "modpath", "/usr/local/lib64/opensips/perl/")
modparam("perl", "filename", "/usr/local/etc/opensips/perlfunctions.pl")


#### MaxMind GeoIP module
#loadmodule "mmgeoip.so"
#modparam("mmgeoip", "mmgeoip_city_db_path", "/usr/local/etc/opensips/GeoLiteCity.dat")

loadmodule "textops.so"

loadmodule "exec.so"
modparam("exec", "async", 1)

####### Routing Logic ########

# main request routing logic

route{

	if (!mf_process_maxfwd_header("10")) {
		send_reply("483","Too Many Hops");
		exit;
	}


	if (is_method("PUBLISH")) {
		send_reply("501","Not Implemented");
		exit;
	}


#---- Sequential requests section ----#

	if (has_totag()) {
# sequential request withing a dialog should
# take the path determined by record-routing
		if (loose_route()) {
			if (is_method("SUBSCRIBE")) {
				t_check_trans();
				if (client_nat_test("1"))
					fix_contact();
			}
			else if (is_method("BYE")) {
				if (!validate_dialog())
					fix_route_dialog();
				xlog("L_INFO","BYE from $fu to $tu\n");
				if ($dlg_val("callLog_end_sent") == "0") {
					if ($(fU{s.len}) > 5)
						perl_exec("call_finish_send_threading");
					$dlg_val("callLog_end_sent") = "1";
				}
				end_media_session();
				setflag(ACC_DO); # do accounting ...
					setflag(ACC_FAILED); # ... even if the transaction fails
			}
			else if (is_method("INVITE")) {
				if (stream_exists("video")) {
					xlog("L_INFO","VIDEO");
				}
				use_media_proxy();
			}
# route it out to whatever destination was set by loose_route()
# in $du (destination URI).
			route(relay);
		}
		else {
			if ( is_method("ACK") ) {
				if ( t_check_trans() ) {
# non loose-route, but stateful ACK; must be an ACK after 
# a 487 or e.g. 404 from upstream server
					t_relay();
					exit;
				}
				else {
# ACK without matching transaction ->
# ignore and discard
					exit;
				}
			}
			send_reply("404","Not here");
		}
		exit;
	}



#---- Initial requests section ----#


# CANCEL processing
	if (is_method("CANCEL"))
	{
		if (t_check_trans())
			t_relay();
		exit;
	}

	t_check_trans();


	if (is_method("REGISTER")) {
#		if ($hdr(Contact) != null)
#			perl_exec("updateUsrLoc");
		$var(auth_code) = www_authorize("","radcheck");
		if ( $var(auth_code) < 0 ) {
			if ($var(auth_code) == -5)
				xlog("L_ERROR","Auth error for $fu from $si");
			www_challenge("", "0");
			exit;
		}

		if (!db_check_to())
		{
			send_reply("403","Forbidden auth ID");
			exit;
		}

		if (proto==TCP || proto==TLS)
			setflag(TCP_PERSISTENT);

		fix_contact();

		if (!save("location","c01f","$fu"))
			sl_reply_error();

		if ($hdr(expires) != "0" && $hdr(expires) != null)
		{
			cache_store("local","auth_$tU","1",630);
#			if (!cache_store("memcached","loc_$tU","SIP_MEMCACHED_HOST",630))
#				xlog("L_ERR","Method: $rm , write cache failed\n");
		}
		else {
			cache_remove("local","auth_$tU");
#			cache_remove("memcached","loc_$tU");
		}
		xlog("L_INFO","$fu from $si REGISTERED");
		exit;
	}


	if ($rU==NULL) {
# request with no Username in RURI
		send_reply("484","Address Incomplete");
		exit;
	}


	if (is_method("SUBSCRIBE")) {
		if (is_from_local()) {
			if ($si=~"^104\.236\.13" || cache_fetch("local","auth_$fU",$var(ip))) {
				record_route();
				if (!lookup("location")) {
#					if (cache_fetch("memcached","loc_$tU",$var(ip)) && $var(ip) != "SIP_MEMCACHED_HOST") {
#						$du = "sip:" + $var(ip);
#					t_relay();
#					exit;
#				}

					send_reply("480","User is offline");
				}
				else
					t_relay();

				exit;
			}
		}

		send_reply("403","Relay forbidden");
		exit;
	}

	if (!(is_method("REGISTER"))) {
		xlog("L_ERROR","$ru");
		if (from_uri==myself) {
			$var(auth_code) = proxy_authorize("","radcheck");
			if ( $var(auth_code) < 0 ) {
				if ($var(auth_code) == -5)
					xlog("L_ERROR","Auth error for $fu from $si");
				proxy_challenge("", "0");
				exit;
			}

			if (!db_check_from()) {
				send_reply("403","Forbidden auth ID");
				exit;
			}

			consume_credentials();
# caller authenticated

		}
		else {
			if (!uri==myself) {
				send_reply("403","Relay forbidden");
				exit;
			}
		}
	}


	force_rport();


# preloaded route checking
#	if (loose_route()) {

#		xlog("L_ERR","Attempt to route with preloaded Route's [$fu/$tu/$ru/$ci]");
#		if (!is_method("ACK"))
#			send_reply("403","Preload Route denied");
#		exit;
#	}


# record routing
	if (!is_method("REGISTER"))
		record_route();


	if (is_method("INVITE")) {

		xlog("L_INFO","INVITE from $fu at $si to $tu\n");
		perl_exec("refreshUsrLoc");

		if (!create_dialog("B")) {
			send_reply("500","Internal Server Error");
			exit;
		}

#		if (mmg_lookup("cc","$si","$avp(country_code)"))
#			xlog("L_INFO","Request is sent from $avp(country_code)\n");

		if ($rU=~"^\*") {
			strip(1);  
			xlog("L_INFO","Relay to datacenter freesw\n");
			t_relay("SIP_RELAY_HOST:SIP_RELAY_PORT");
			exit;
		}

		if (!lookup("location","m")) {
#			if (cache_fetch("memcached","loc_$tU",$var(ip)) && $var(ip) != "SIP_IPADDR")
#				$du = "sip:" + $var(ip);
#		else {
#			send_reply("480","User is offline");
			xlog("L_INFO","Method $rm from $fu at $si: $tu is offline\n");
			perl_exec("send_offline_threading","offline");
			$var(i) = "sip:slot" + $fU + "@SIP_DOMAIN";
			$ru = $var(i);
			t_on_failure("wakeup");
			t_relay();
			exit;
#		}
		}

		if (!is_present_hf("Record-Route")) {
			xlog("L_INFO","There is no RR header, must be fresh INVITE\n");
			$dlg_val("caller_ip") = $si;
			use_media_proxy();
			$dlg_val("callLog_start_sent") = "0";
			$dlg_val("callLog_end_sent") = "0";
		}
		else
			xlog("L_INFO","Found RR header, ignore\n");

# when routing via usrloc, log the missed calls also
		setflag(ACC_MISSED);

		route(relay);
	}


	send_reply("403","Forbidden");
	exit;
}


route[relay] {
	if (is_method("INVITE")) {
		t_on_branch("per_branch_ops");
		t_on_reply("handle_nat");
		t_on_failure("missed_call");
	}
	else if (is_method("SUBSCRIBE")) {
		t_on_reply("fix_202");
	}
	if (!t_relay()) {
		send_reply("500","Internal Error");
	};
	exit;
}


branch_route[per_branch_ops] {
	xlog("L_INFO","new branch at $ru\n");
}

failure_route[wakeup] {
	xlog("Delay, biatch $tu");
	if (!lookup("location","m","$tu")) {
		xlog("L_INFO","Method $rm from $fu at $si: $tu is offline\n");
		$ru = "sip:delay" + $fU + "@SIP_DOMAIN";
		t_on_failure("wakeup");
		t_relay();
		exit;
	}

	setflag(ACC_DO); # do accounting

	if (!is_present_hf("Record-Route")) {
		$dlg_val("caller_ip") = $si;
		use_media_proxy();
		$dlg_val("callLog_start_sent") = "0";
		$dlg_val("callLog_end_sent") = "0";
	}

	setflag(ACC_MISSED);
	route(relay);
}

onreply_route[handle_nat] {
	xlog("L_INFO","incoming reply from $tu, status code = $rs, reason: $rr\n");
	if (t_check_status("200")) {
		if ($hdrcnt(Via) == 2) {
			use_media_proxy();
			if ($dlg_val("callLog_start_sent") == "0") {
				$avp(callee_ip) = $si;
				$avp(caller_ip) = $dlg_val("caller_ip");
				if ($(fU{s.len}) > 5)
					perl_exec("call_start_send_threading");
				$dlg_val("callLog_start_sent") = "1";
			}
			if (stream_exists("video")) {
				if ( search_body("inactive") ) {
					$var(cmd) = "rm -rf /tmp/" + $fU + "@" + $td + "_1 /tmp/" + $tU + "@" + $td + "_1";
					exec_msg("$var(cmd)");
				}
			}
		}
	}
}


onreply_route[fix_202] {
	if (t_check_status("202")) {
		if (client_nat_test("1"))
			fix_contact();
	}
}

failure_route[missed_call] {

	end_media_session();
	if (t_was_cancelled()) {
		exit;
	}

# uncomment the following lines if you want to block client 
# redirect based on 3xx replies.
##if (t_check_status("3[0-9][0-9]")) {
##t_reply("404","Not found");
##	exit;
##}


# redirect the failed to a different VM system
#if (t_check_status("486|408")) {
#	$du = "sip:127.0.0.1:5060"; # CUSTOMIZE ME
#	#do not set the missed call flag again
#	route(relay);
#}
}


failure_route[LB_failed]
{
# skip if call was canceled
	if (t_was_cancelled()) {
		exit;
	}

# was a destination failure ? (we do not want to do failover
# if it was a call setup failure, so we look for 500 and 600
# class replied and for local timeouts)


}


local_route {
	if (is_method("BYE") && $DLG_dir=="UPSTREAM") {
#acc_db_request("200 Dialog Timeout", "acc");
	}
}
